generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ================================
// USUARIOS Y AUTENTICACI√ìN
// ================================

model User {
  id        String   @id @default(cuid())
  username  String   @unique
  email     String?  @unique
  password  String
  role      String   @default("OPERATOR") // ADMIN | MANAGER | OPERATOR | VIEWER | DJ | RECEPTION
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  permissions UserPermission[]
  events      Event[]          @relation("EventCreator")

  @@map("users")
}

model UserPermission {
  id        String  @id @default(cuid())
  userId    String
  module    String // MUSICADJ | KARAOKEYA | VENUES | EVENTS | CLIENTS | USERS
  canView   Boolean @default(true)
  canEdit   Boolean @default(false)
  canDelete Boolean @default(false)
  canExport Boolean @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, module])
  @@index([userId])
  @@index([module])
  @@map("user_permissions")
}

// ================================
// VENUES Y CLIENTS (REUTILIZABLES)
// ================================

model Venue {
  id           String   @id @default(cuid())
  name         String
  type         String   @default("OTHER") // SALON | BAR | DISCO | RESTAURANT | CLUB | OUTDOOR | OTHER
  address      String?
  city         String?
  capacity     Int?
  contactName  String?
  contactPhone String?
  instagramUrl String?
  notes        String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  events Event[]

  @@map("venues")
}

model Client {
  id        String   @id @default(cuid())
  name      String
  company   String?
  phone     String?
  email     String?
  cuit      String?
  notes     String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  events Event[]

  @@map("clients")
}

// ================================
// PARTICIPANTES (ACCESO P√öBLICO A SERVICIOS)
// ================================

// Participant = usuario final que accede via QR (sin password)
// Identificaci√≥n por email, cross-evento
// Usado para MUSICADJ y KARAOKEYA
model Participant {
  id                  String   @id @default(cuid())
  email               String   @unique
  displayName         String // "Juancho", "La Voz de Oro", etc.
  whatsapp            String? // Opcional, para notificaciones de turno
  isSystemParticipant Boolean  @default(false) // true para participantes internos (ej: IMPORTACION)
  createdAt           DateTime @default(now())
  lastSeenAt          DateTime @updatedAt

  // Relaci√≥n opcional con Person (invitado formal)
  person          Person?           @relation("PersonParticipant")
  songRequests    SongRequest[]
  karaokeRequests KaraokeRequest[]
  likedSongs      KaraokeSongLike[]

  @@map("participants")
}

// ================================
// INVITADOS (LISTA FORMAL DEL EVENTO)
// ================================

// Person = Cat√°logo global de personas (reutilizable entre eventos)
model Person {
  id                  String   @id @default(cuid())
  nombre              String
  apellido            String
  email               String?  @unique // Opcional, √∫nico si existe
  phone               String?
  company             String?
  dietaryRestrictions String?  @default("[]") // JSON: ["VEGANO", "CELIACO"]
  identityHash        String // SHA256(email + nombre + apellido) para detectar duplicados
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  createdBy           String? // userId

  // Relaci√≥n opcional con Participant (si usa servicios p√∫blicos)
  participantId String?      @unique
  participant   Participant? @relation("PersonParticipant", fields: [participantId], references: [id])

  // Relaci√≥n con eventos
  eventGuests EventGuest[]

  @@index([email])
  @@index([apellido, nombre])
  @@index([identityHash])
  @@map("persons")
}

// EventGuest = Entrada en la guestlist de un evento
model EventGuest {
  id            String    @id @default(cuid())
  eventId       String
  personId      String
  mesaId        String?
  estadoIngreso String    @default("PENDIENTE") // PENDIENTE | INGRESADO | NO_ASISTIO
  checkedInAt   DateTime?
  checkedInBy   String? // userId del recepcionista
  checkedOutAt  DateTime? // Solo si Event.requiereCheckout = true
  checkedOutBy  String? // userId del recepcionista
  observaciones String?
  accesibilidad String? // NINGUNA | MOVILIDAD_REDUCIDA | VISUAL | AUDITIVA | OTRA
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  addedBy       String? // userId

  event       Event       @relation("EventGuests", fields: [eventId], references: [id], onDelete: Cascade)
  person      Person      @relation(fields: [personId], references: [id], onDelete: Cascade)
  mesa        Mesa?       @relation("MesaGuests", fields: [mesaId], references: [id], onDelete: SetNull)
  guestDishes GuestDish[]

  @@unique([eventId, personId])
  @@index([eventId])
  @@index([eventId, estadoIngreso])
  @@index([personId])
  @@index([mesaId])
  @@map("event_guests")
}

// ================================
// MEN√ö Y PLATOS
// ================================

// Dish = Cat√°logo global de platos
model Dish {
  id          String   @id @default(cuid())
  nombre      String
  descripcion String?
  categoria   String   @default("PRINCIPAL") // Categor√≠a sugerida: ENTRADA, PRINCIPAL, POSTRE, etc.
  dietaryInfo String   @default("[]") // JSON: ["VEGANO", "SIN_GLUTEN", "SIN_LACTOSA"]
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?

  eventDishes EventDish[]

  @@index([nombre])
  @@index([isActive])
  @@index([categoria])
  @@map("dishes")
}

// DishCategory = Categor√≠as de platos (configurables por evento)
model DishCategory {
  id                    String   @id @default(cuid())
  eventId               String? // NULL = categor√≠a global (default), eventId = custom del evento
  nombre                String // "ENTRADA", "PRINCIPAL", "POSTRE", etc.
  orden                 Int      @default(0)
  isSystemDefault       Boolean  @default(false) // true para ENTRADA, PRINCIPAL, POSTRE, BUFFET
  allowMultipleDefaults Boolean  @default(false) // true para categor√≠as como "DEGUSTACI√ìN" que permiten varios defaults
  createdAt             DateTime @default(now())

  event       Event?      @relation("EventCategories", fields: [eventId], references: [id], onDelete: Cascade)
  eventDishes EventDish[]

  @@unique([eventId, nombre])
  @@index([eventId])
  @@map("dish_categories")
}

// EventDish = Platos del men√∫ de un evento espec√≠fico
model EventDish {
  id         String   @id @default(cuid())
  eventId    String
  dishId     String
  categoryId String
  isDefault  Boolean  @default(false) // Plato default de la categor√≠a
  orden      Int      @default(0)
  createdAt  DateTime @default(now())

  event       Event        @relation("EventMenu", fields: [eventId], references: [id], onDelete: Cascade)
  dish        Dish         @relation(fields: [dishId], references: [id], onDelete: Cascade)
  category    DishCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  guestDishes GuestDish[]

  @@unique([eventId, dishId])
  @@index([eventId])
  @@index([eventId, categoryId])
  @@map("event_dishes")
}

// GuestDish = Platos asignados a un invitado
model GuestDish {
  id           String   @id @default(cuid())
  eventGuestId String
  eventDishId  String
  assignedAt   DateTime @default(now())
  assignedBy   String? // null = autom√°tico, userId = manual

  eventGuest EventGuest @relation(fields: [eventGuestId], references: [id], onDelete: Cascade)
  eventDish  EventDish  @relation(fields: [eventDishId], references: [id], onDelete: Cascade)

  @@unique([eventGuestId, eventDishId])
  @@index([eventGuestId])
  @@index([eventDishId])
  @@map("guest_dishes")
}

// ================================
// MESAS Y SAL√ìN
// ================================

model Mesa {
  id            String   @id @default(cuid())
  eventId       String
  numero        String // "5", "VIP-1", "A1"
  capacidad     Int
  forma         String   @default("REDONDA") // REDONDA | CUADRADA | RECTANGULAR | OVALADA | HERRADURA
  sector        String? // "VIP", "General", "Terraza"
  posX          Float? // Coordenada X en el plano del sal√≥n
  posY          Float? // Coordenada Y en el plano del sal√≥n
  rotation      Float?   @default(0) // Rotaci√≥n en grados
  observaciones String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  createdBy     String?

  event     Event        @relation("EventMesas", fields: [eventId], references: [id], onDelete: Cascade)
  invitados EventGuest[] @relation("MesaGuests")

  @@unique([eventId, numero])
  @@index([eventId])
  @@index([eventId, sector])
  @@map("mesas")
}

// ================================
// EVENTOS
// ================================

model Event {
  id           String   @id @default(cuid())
  slug         String   @unique // URL amigable: "martina-15-2501"
  status       String   @default("DRAFT") // DRAFT | ACTIVE | PAUSED | FINISHED
  venueId      String?
  clientId     String?
  clonedFromId String?
  createdById  String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Configuraci√≥n operativa de invitados
  tieneMesasAsignadas Boolean @default(true)
  tieneMenuIndividual Boolean @default(true)
  requiereCheckout    Boolean @default(false)
  checkinAccessToken  String? @unique // Token para acceso directo a check-in sin login

  // Configuraci√≥n de sal√≥n (para distribuci√≥n espacial de mesas)
  salonAncho    Float? // Ancho en metros
  salonLargo    Float? // Largo en metros
  salonImageUrl String? // URL del plano del sal√≥n

  venue      Venue?  @relation(fields: [venueId], references: [id])
  client     Client? @relation(fields: [clientId], references: [id])
  clonedFrom Event?  @relation("EventClones", fields: [clonedFromId], references: [id])
  clones     Event[] @relation("EventClones")
  createdBy  User    @relation("EventCreator", fields: [createdById], references: [id])

  eventData       EventData?
  musicadjConfig  MusicadjConfig?
  songRequests    SongRequest[]
  clientPlaylists ClientPlaylist[]
  karaokeyaConfig KaraokeyaConfig?
  karaokeRequests KaraokeRequest[]

  // Relaciones con m√≥dulos de invitados
  mesas            Mesa[]         @relation("EventMesas")
  eventGuests      EventGuest[]   @relation("EventGuests")
  eventMenu        EventDish[]    @relation("EventMenu")
  customCategories DishCategory[] @relation("EventCategories")

  @@map("events")
}

model EventData {
  id              String    @id @default(cuid())
  eventId         String    @unique
  eventName       String
  eventType       String    @default("OTHER") // WEDDING | FIFTEEN | CORPORATE | BIRTHDAY | PARTY | BAR | PRIVATE_PARTY | COMMERCIAL | SHOW | DJ_SET | OTHER
  startDate       DateTime
  endDate         DateTime?
  guestCount      Int?
  instagramUrl    String?
  instagramUser   String?
  instagram       String? // Instagram handle or URL
  facebook        String? // Facebook page URL
  twitter         String? // Twitter/X handle or URL
  website         String? // Event website URL
  eventImage      String? // Event image URL
  hashtag         String?
  spotifyPlaylist String?
  notes           String?
  customFields    String? // JSON para campos adicionales

  // Colores personalizables del tema (hex)
  primaryColor   String @default("#7C3AED") // P√∫rpura
  secondaryColor String @default("#EC4899") // Rosa
  accentColor    String @default("#F59E0B") // √Åmbar

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("event_data")
}

// ================================
// M√ìDULO MUSICADJ
// ================================

model MusicadjConfig {
  eventId             String  @id
  enabled             Boolean @default(true)
  cooldownSeconds     Int     @default(300)
  allowWithoutSpotify Boolean @default(true)
  welcomeMessage      String?
  showQueueToClient   Boolean @default(false)
  // v1.4: Mensajes configurables
  customMessages      String? // JSON opcional para override de mensajes

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("musicadj_configs")
}

model SongRequest {
  id                 String   @id @default(cuid())
  eventId            String
  participantId      String // FK al Participant (usuario con email)
  spotifyId          String?
  title              String
  artist             String
  albumArtUrl        String?
  status             String   @default("PENDING") // PENDING | HIGHLIGHTED | URGENT | PLAYED | DISCARDED
  priority           Int      @default(0)
  playlistId         String? // ID de la playlist de origen (opcional)
  fromClientPlaylist Boolean  @default(false) // Marca visual para pedidos de playlist
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  event       Event           @relation(fields: [eventId], references: [id], onDelete: Cascade)
  participant Participant     @relation(fields: [participantId], references: [id])
  playlist    ClientPlaylist? @relation(fields: [playlistId], references: [id])

  @@index([eventId, status])
  @@index([eventId, createdAt])
  @@index([participantId])
  @@index([playlistId])
  @@map("song_requests")
}

model ClientPlaylist {
  id                String   @id @default(cuid())
  eventId           String
  spotifyPlaylistId String   @unique
  name              String
  description       String?
  trackCount        Int
  tracksData        String? // JSON con los tracks de la playlist
  importedAt        DateTime @default(now())
  importedBy        String // userId

  event        Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  songRequests SongRequest[]

  @@index([eventId])
  @@index([spotifyPlaylistId])
  @@map("client_playlists")
}

// ================================
// M√ìDULO KARAOKEYA
// ================================

// Cat√°logo maestro de canciones (global, no por evento)
// v1.4: Integraci√≥n con YouTube + normalizaci√≥n de t√≠tulos
// v2.0: CRUD, ranking, opiniones y sistema de likes
model KaraokeSong {
  id              String   @id @default(cuid())
  title           String // T√≠tulo normalizado (sin artista ni extras)
  artist          String // Artista normalizado
  youtubeId       String   @unique // ID √∫nico de YouTube (ej: "fJ9rUzIMcZQ")
  youtubeShareUrl String // Link compartible: https://youtu.be/{youtubeId}
  thumbnailUrl    String? // Thumbnail del video para preview
  duration        Int? // Duraci√≥n en segundos
  source          String   @default("YOUTUBE") // YOUTUBE | MANUAL | IMPORTED
  language        String   @default("ES") // ES | EN | PT
  difficulty      String   @default("MEDIO") // FACIL | MEDIO | DIFICIL | PAVAROTTI
  ranking         Int      @default(3) // Calificaci√≥n de calidad 1-5 (‚≠ê a ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê)
  opinion         String? // Opini√≥n editorial del operador
  moods           String   @default("[]") // JSON array: ["PARA_ROMPERLA", "ROMANTICO", etc.]
  tags            String   @default("[]") // JSON array: ["Popular", "Cl√°sico", "D√∫o"]
  timesRequested  Int      @default(1) // Contador de popularidad (inicia en 1 al crear)
  timesCompleted  Int      @default(0) // Veces cantada exitosamente
  likesCount      Int      @default(0) // Contador global de "me gusta"
  isActive        Boolean  @default(true) // Para ocultar sin eliminar
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  requests KaraokeRequest[]
  likes    KaraokeSongLike[]

  @@index([youtubeId])
  @@index([language])
  @@index([difficulty])
  @@index([ranking]) // Para ordenar por calificaci√≥n
  @@index([likesCount]) // Para ordenar por popularidad de likes
  @@index([timesRequested]) // Para ordenar por popularidad
  @@map("karaoke_songs")
}

model KaraokeyaConfig {
  eventId               String  @id
  enabled               Boolean @default(true)
  cooldownSeconds       Int     @default(600)
  maxPerPerson          Int     @default(0) // 0 = sin l√≠mite
  showQueueToClient     Boolean @default(true)
  showNextSinger        Boolean @default(true)
  // Configuraci√≥n de sugerencias
  suggestionsEnabled    Boolean @default(true)
  suggestionsCount      Int     @default(3) // 0-5, cantidad de sugerencias a mostrar
  allowedLanguages      String  @default("[]") // JSON array: ["ES", "EN"] o vac√≠o = todos
  // v1.4: YouTube + Mensajes configurables
  youtubeSearchKeywords String  @default("[\"letra\", \"lyrics\"]") // Keywords para b√∫squeda YouTube
  customMessages        String? // JSON opcional para override de mensajes: {"search.placeholder": "..."}

  // v2.0: Display Screen (Pantalla p√∫blica de karaoke)
  displayMode          String  @default("QUEUE") // QUEUE | BREAK | START | PROMO
  displayLayout        String  @default("HORIZONTAL") // VERTICAL | HORIZONTAL
  displayBreakMessage  String  @default("¬°Ya regresamos! üé§") // Mensaje personalizable para modo BREAK
  displayStartMessage  String  @default("¬°Ya comenzamos! üéâ") // Mensaje personalizable para modo START
  displayPromoImageUrl String? // URL de imagen promocional para modo PROMO

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("karaokeya_configs")
}

model KaraokeRequest {
  id            String    @id @default(cuid())
  eventId       String
  participantId String // FK al Participant (usuario con email)
  songId        String? // FK opcional al cat√°logo (null si b√∫squeda manual)
  title         String
  artist        String?
  turnNumber    Int
  queuePosition Int
  status        String    @default("QUEUED") // QUEUED | CALLED | ON_STAGE | COMPLETED | NO_SHOW | CANCELLED
  createdAt     DateTime  @default(now())
  calledAt      DateTime?

  event       Event        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  participant Participant  @relation(fields: [participantId], references: [id])
  song        KaraokeSong? @relation(fields: [songId], references: [id])

  @@index([eventId, status])
  @@index([eventId, queuePosition])
  @@index([participantId])
  @@index([songId])
  @@map("karaoke_requests")
}

// Sistema de "Me Gusta" para canciones de karaoke (global, cross-evento)
model KaraokeSongLike {
  id            String   @id @default(cuid())
  songId        String
  participantId String
  createdAt     DateTime @default(now())

  song        KaraokeSong @relation(fields: [songId], references: [id], onDelete: Cascade)
  participant Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)

  @@unique([songId, participantId]) // Prevenir duplicados: un participant solo puede dar like una vez por canci√≥n
  @@index([songId])
  @@index([participantId])
  @@map("karaoke_song_likes")
}
