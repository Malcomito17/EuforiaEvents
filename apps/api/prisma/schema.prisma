generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ================================
// USUARIOS Y AUTENTICACIÓN
// ================================

model User {
  id        String   @id @default(cuid())
  username  String   @unique
  email     String?  @unique
  password  String
  role      String   @default("OPERATOR")  // ADMIN | OPERATOR | VIEWER
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  permissions UserPermission[]
  events      Event[]          @relation("EventCreator")

  @@map("users")
}

model UserPermission {
  id         String  @id @default(cuid())
  userId     String
  module     String  // MUSICADJ | KARAOKEYA | VENUES | EVENTS | CLIENTS | USERS
  canView    Boolean @default(true)
  canEdit    Boolean @default(false)
  canDelete  Boolean @default(false)
  canExport  Boolean @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, module])
  @@index([userId])
  @@index([module])
  @@map("user_permissions")
}

// ================================
// VENUES Y CLIENTS (REUTILIZABLES)
// ================================

model Venue {
  id           String   @id @default(cuid())
  name         String
  type         String   @default("OTHER")  // SALON | BAR | RESTAURANT | CLUB | OUTDOOR | OTHER
  address      String?
  city         String?
  capacity     Int?
  contactName  String?
  contactPhone String?
  instagramUrl String?
  notes        String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  events Event[]

  @@map("venues")
}

model Client {
  id        String   @id @default(cuid())
  name      String
  company   String?
  phone     String?
  email     String?
  cuit      String?
  notes     String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  events Event[]

  @@map("clients")
}

// ================================
// INVITADOS (ACCESO SIMPLIFICADO)
// ================================

// Guest = usuario final que accede via QR (sin password)
// Identificación por email, cross-evento
model Guest {
  id          String   @id @default(cuid())
  email       String   @unique
  displayName String   // "Juancho", "La Voz de Oro", etc.
  whatsapp    String?  // Opcional, para notificaciones de turno
  createdAt   DateTime @default(now())
  lastSeenAt  DateTime @updatedAt

  songRequests    SongRequest[]
  karaokeRequests KaraokeRequest[]
  likedSongs      KaraokeSongLike[]

  @@map("guests")
}

// ================================
// EVENTOS
// ================================

model Event {
  id           String   @id @default(cuid())
  slug         String   @unique  // URL amigable: "martina-15-2501"
  status       String   @default("DRAFT")  // DRAFT | ACTIVE | PAUSED | FINISHED
  venueId      String?
  clientId     String?
  clonedFromId String?
  createdById  String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  venue      Venue?  @relation(fields: [venueId], references: [id])
  client     Client? @relation(fields: [clientId], references: [id])
  clonedFrom Event?  @relation("EventClones", fields: [clonedFromId], references: [id])
  clones     Event[] @relation("EventClones")
  createdBy  User    @relation("EventCreator", fields: [createdById], references: [id])

  eventData       EventData?
  musicadjConfig  MusicadjConfig?
  songRequests    SongRequest[]
  karaokeyaConfig KaraokeyaConfig?
  karaokeRequests KaraokeRequest[]

  @@map("events")
}

model EventData {
  id              String    @id @default(cuid())
  eventId         String    @unique
  eventName       String
  eventType       String    @default("OTHER")  // WEDDING | FIFTEEN | CORPORATE | BIRTHDAY | PARTY | OTHER
  startDate       DateTime
  endDate         DateTime?
  guestCount      Int?
  instagramUrl    String?
  instagramUser   String?
  hashtag         String?
  spotifyPlaylist String?
  notes           String?
  customFields    String?   // JSON para campos adicionales

  // Colores personalizables del tema (hex)
  primaryColor    String    @default("#7C3AED")  // Púrpura
  secondaryColor  String    @default("#EC4899")  // Rosa
  accentColor     String    @default("#F59E0B")  // Ámbar

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("event_data")
}

// ================================
// MÓDULO MUSICADJ
// ================================

model MusicadjConfig {
  eventId             String  @id
  enabled             Boolean @default(true)
  cooldownSeconds     Int     @default(300)
  allowWithoutSpotify Boolean @default(true)
  welcomeMessage      String?
  showQueueToClient   Boolean @default(false)
  // v1.4: Mensajes configurables
  customMessages      String? // JSON opcional para override de mensajes

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("musicadj_configs")
}

model SongRequest {
  id          String   @id @default(cuid())
  eventId     String
  guestId     String   // FK al Guest (identificación unificada)
  spotifyId   String?
  title       String
  artist      String
  albumArtUrl String?
  status      String   @default("PENDING")  // PENDING | HIGHLIGHTED | URGENT | PLAYED | DISCARDED
  priority    Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  guest Guest @relation(fields: [guestId], references: [id])

  @@index([eventId, status])
  @@index([eventId, createdAt])
  @@index([guestId])
  @@map("song_requests")
}

// ================================
// MÓDULO KARAOKEYA
// ================================

// Catálogo maestro de canciones (global, no por evento)
// v1.4: Integración con YouTube + normalización de títulos
// v2.0: CRUD, ranking, opiniones y sistema de likes
model KaraokeSong {
  id              String   @id @default(cuid())
  title           String   // Título normalizado (sin artista ni extras)
  artist          String   // Artista normalizado
  youtubeId       String   @unique  // ID único de YouTube (ej: "fJ9rUzIMcZQ")
  youtubeShareUrl String   // Link compartible: https://youtu.be/{youtubeId}
  thumbnailUrl    String?  // Thumbnail del video para preview
  duration        Int?     // Duración en segundos
  source          String     @default("YOUTUBE")  // YOUTUBE | MANUAL | IMPORTED
  language        String     @default("ES")  // ES | EN | PT
  difficulty      String     @default("MEDIO") // FACIL | MEDIO | DIFICIL | PAVAROTTI
  ranking         Int        @default(3)     // Calificación de calidad 1-5 (⭐ a ⭐⭐⭐⭐⭐)
  opinion         String?                    // Opinión editorial del operador
  moods           String     @default("[]")  // JSON array: ["PARA_ROMPERLA", "ROMANTICO", etc.]
  tags            String     @default("[]")  // JSON array: ["Popular", "Clásico", "Dúo"]
  timesRequested  Int        @default(1)     // Contador de popularidad (inicia en 1 al crear)
  timesCompleted  Int        @default(0)     // Veces cantada exitosamente
  likesCount      Int        @default(0)     // Contador global de "me gusta"
  isActive        Boolean    @default(true)  // Para ocultar sin eliminar
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  requests KaraokeRequest[]
  likes    KaraokeSongLike[]

  @@index([youtubeId])
  @@index([language])
  @@index([difficulty])
  @@index([ranking])         // Para ordenar por calificación
  @@index([likesCount])      // Para ordenar por popularidad de likes
  @@index([timesRequested])  // Para ordenar por popularidad
  @@map("karaoke_songs")
}

model KaraokeyaConfig {
  eventId               String  @id
  enabled               Boolean @default(true)
  cooldownSeconds       Int     @default(600)
  maxPerPerson          Int     @default(0)  // 0 = sin límite
  showQueueToClient     Boolean @default(true)
  showNextSinger        Boolean @default(true)
  // Configuración de sugerencias
  suggestionsEnabled    Boolean @default(true)
  suggestionsCount      Int     @default(3)  // 0-5, cantidad de sugerencias a mostrar
  allowedLanguages      String  @default("[]")  // JSON array: ["ES", "EN"] o vacío = todos
  // v1.4: YouTube + Mensajes configurables
  youtubeSearchKeywords String  @default("[\"letra\", \"lyrics\"]")  // Keywords para búsqueda YouTube
  customMessages        String? // JSON opcional para override de mensajes: {"search.placeholder": "..."}

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("karaokeya_configs")
}

model KaraokeRequest {
  id            String    @id @default(cuid())
  eventId       String
  guestId       String    // FK al Guest (identificación unificada)
  songId        String?   // FK opcional al catálogo (null si búsqueda manual)
  title         String
  artist        String?
  turnNumber    Int
  queuePosition Int
  status        String    @default("QUEUED")  // QUEUED | CALLED | ON_STAGE | COMPLETED | NO_SHOW | CANCELLED
  createdAt     DateTime  @default(now())
  calledAt      DateTime?

  event Event        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  guest Guest        @relation(fields: [guestId], references: [id])
  song  KaraokeSong? @relation(fields: [songId], references: [id])

  @@index([eventId, status])
  @@index([eventId, queuePosition])
  @@index([guestId])
  @@index([songId])
  @@map("karaoke_requests")
}

// Sistema de "Me Gusta" para canciones de karaoke (global, cross-evento)
model KaraokeSongLike {
  id        String   @id @default(cuid())
  songId    String
  guestId   String
  createdAt DateTime @default(now())

  song  KaraokeSong @relation(fields: [songId], references: [id], onDelete: Cascade)
  guest Guest       @relation(fields: [guestId], references: [id], onDelete: Cascade)

  @@unique([songId, guestId])  // Prevenir duplicados: un guest solo puede dar like una vez por canción
  @@index([songId])
  @@index([guestId])
  @@map("karaoke_song_likes")
}
